# -*- coding: utf-8 -*-
"""Udobang_Joshua_ps2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BZJ7WqFYupQtVqVIAIvPWEFFdOV4TYb9

**Task 1: Visualization (20 points)**

For this task, you will write a Python script or notebook, please make sure all your code is well structured,
understandable and reproducible.
The Workspace is a continuous 2D area: W = R×R with obstacles. The target object is the 2D manipulatorlike mechanism which consist of 4 links, with "root" joint at (0, 0). The configuration of the manipulator is
expressed as q = [θ1, θ2, θ3, θ4], where θi ∈ (−180; 180] is the angle of the link relative to its joint in degrees.
Both angles and coordinates on the plane are continuous variables. Note that intersection of the links is allowed
(imagine that all links are in different planes).

All the required data can be obtained from PS2_data.pickle. See main.py to check how to load the
data. The pickle file consist of the dictionary with the following fields:
• start_state and goal_state are the [4,] arrays with the starting configuration and the target
configuration to reach
• obstacles is the [6, 3] array of the circular obstacles in format [x, y, radius]
• collision_threshold is the float number that defines minimal allowed distance to the obstacle
To see how display the manipulator in desired state, check environment.py file.

**A. (10 pts)** Visualize the manipulator in the start state and target state. Comment on your thoughts about
comparison the discretized orientation space from PS1 vs continuous orientation space in current problem
set.
"""

import pickle
import matplotlib.pyplot as plt
from environment import State, ManipulatorEnv
import numpy as np

# Load the data from PS2_data.pickle
with open('/content/data.pickle', 'rb') as file:
    data = pickle.load(file)

# Get the start state and goal state
start_state = State(np.array(data["start_state"]))
goal_state = State(np.array(data["goal_state"]))

# Initialize the environment
env = ManipulatorEnv(obstacles=np.array(data["obstacles"]),
                         initial_state=start_state,
                         collision_threshold=data["collision_threshold"])

# Plot the start state
# plt.figure()
env.render()
# plt.title('Start State')

# Plot the goal state
# plt.figure()
env = ManipulatorEnv(obstacles=np.array(data["obstacles"]),
                         initial_state=goal_state,
                         collision_threshold=data["collision_threshold"])
env.render()
# plt.title('Goal State')

# Show the plots
plt.show()

"""Comparing the discretized orientation space from Problem Set 1 with the continuous orientation space in this problem set, we can see some key differences. In PS1, the orientation space was discretized into a set number of angles, and the rod was only allowed to occupy those discrete angles. However, in this problem set, the orientation space is continuous, meaning that the manipulator can be in any angle between -180 and 180 degrees.

This continuous orientation space allows for greater flexibility and precision in controlling the manipulator's movement. It allows for smoother transitions between angles and enables the manipulator to access positions that might not be possible with the discrete approach. However, it also introduces additional complexity since we need to consider all possible continuous angles when planning the manipulator's motion.

**B. (10 pts)** Visualize the manipulator in 4 random orientations that include both colliding and non-colliding
configurations. Check what does the ManipulatorEnv.check_collision function returns for those
configurations. Comment on your observations.
"""

import pickle
import matplotlib.pyplot as plt
import random
from environment import State, ManipulatorEnv
import numpy as np
# from typing import List, Optional

# Load the data from PS2_data.pickle
with open('/content/data.pickle', 'rb') as file:
    data = pickle.load(file)

# Initialize the environment
start_state=State(np.array(data["start_state"]))

# Generate 4 random orientations
random_orientations = [random.uniform(-180, 180) for _ in range(4)]

# Plot the manipulator in each random orientation
for i, orientation in enumerate(random_orientations):
    state = np.array(data["start_state"]).copy()  # Use the start state as a base
    state[1] = orientation
    env = ManipulatorEnv(obstacles=np.array(data["obstacles"]),initial_state=State(state),collision_threshold=data["collision_threshold"]) # Set the orientation to the random value
    env.render()
    plt.title(f'Random Orientation {i+1}: {orientation}°')

    # Check collision for the current configuration
    collision = env.check_collision(State(state))
    print(f'Collision for Random Orientation {i+1}:', collision)



"""The ManipulatorEnv.check_collision function returns a boolean value indicating whether the current configuration of the manipulator collides with any obstacles in the environment. If False, it means the configuration is collision-free, while True indicates a collision.

Observations:
- For some random orientations, the manipulator is in a non-colliding configuration, meaning it does not intersect any obstacles. In these cases, the check_collision function returns False.
- For other random orientations, the manipulator is in a colliding configuration, where it intersects one or more obstacles. In these cases, the check_collision function returns True.
- The collision status of the manipulator varies based on the position and orientation of its links. Different configurations can lead to collisions or non-collisions depending on the obstacle configuration and the geometry of the manipulator.
- It is important to take into account the orientation of the manipulator when checking for collisions, as it can significantly affect the likelihood of collision with obstacles.

**Task 2: RRT (80 points)**
For this task, you will implement the RRT algorithm to solve the path planning for the 4R manipulator. Follow
the material explained in class

**A. (40 pts)** You need to implement the RRT algorithm for agent in continuous domain. The starting configuration of the agent is (0, 0, 0, 0) and the goal configuration is (-180.0, -60.0, 72.0, -60.0).
For searching nearest pose use L1 distance between two configuration vectors:
distance = $||q_2 − q_1||$ (1)
You may want to use function angle_difference and angle_linspace from angle_utils.py. As a
maximum allowed rotation for each joint we suggest you to use 10 degrees.
Save the result of calculated plan in solve_4R.mp4 (or other video extension) using provided function. If
you want to add more smoothness to the video, you can add additional intermediate configurations, but it’s
optional.
You may want to use the function ManipulatorEnv.check_collision, in order to check if the the
manipulator is in collision at any point towards the new configuration.
Hint: you may want to use the collision check function over a small sequence of configurations, connecting
your current one with the new configuration candiate qnew
"""

import angle_util
from video_util import animate_plan
start_config = np.array([0, 0, 0, 0])
goal_config = np.array([-180.0, -60.0, 72.0, -60.0])
rrt_tree = []
rrt_tree.append(start_config)
max_rotation = 10.0
num_iterations = 7000
#def angle_linspace(start_config, goal_config, step):
 #   assert len(start_config) == len(goal_config), "Lengths of start_config and end_config must be the same"
 #   n = len(start_config)
  #  new_config = []
  #  for i in range(n):
   #     angle_range = np.arange(start_config[i], goal_config[i], step*np.sign(goal_config[i]-start_config[i]))
    #    new_config.append(angle_range[int(len(angle_range)/2)])
    # return np.array(new_config)

for _ in range(num_iterations):
    # Generate a random configuration within the joint limits
    random_config = np.random.uniform(-max_rotation, max_rotation, size=4)

    # Find the nearest configuration in the RRT tree to the random configuration
    nearest_config = min(rrt_tree, key=lambda config: np.sum(np.abs(config - random_config)))

    # Generate a new configuration by incrementally moving towards the random configuration
    new_config = angle_linspace(nearest_config, random_config, 0.1)

    # Check for collision between the nearest configuration and the new configuration
    collision = env.check_collision(State(new_config)) #and env.check_collision(State(nearest_config))

    # If there is no collision, add the new configuration to the RRT tree
    if not collision:
        rrt_tree.append(new_config)

    # Check if the goal configuration is reachable from the new configuration
    if np.allclose(new_config, goal_config, atol=0.1):
        # If the goal is reachable, add the goal configuration to the RRT tree and terminate the algorithm
        rrt_tree.append(goal_config)
        break
animate_plan (ManipulatorEnv(obstacles=np.array(data["obstacles"]),initial_state=State(start_config),collision_threshold=data["collision_threshold"]),rrt_tree, "solve_4R.mp4")

# !cat rrt.py
            #  lambda config: np.sum(np.abs(config - random_config)))

import random
from random import uniform
from rrt import RRTPlanner
from angle_util import angle_difference, angle_linspace
planner = RRTPlanner(env,angle_difference)

plan = planner.plan(start_state, goal_state)
print("RRT planner has finished successfully")

animate_plan(env, plan)



