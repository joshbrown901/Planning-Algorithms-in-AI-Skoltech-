# -*- coding: utf-8 -*-
"""ps_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i5JY1HfEkkoB9kM8PsRUHCKgasx8qnkr
"""

import numpy as np
import matplotlib.pyplot as plt

"""For this task, you will write a Python script or note-book that generates the configuration space, including the
obstacle regions and free space. The Workspace is a rectangular grid area (image) of 100 × 100, such that
W = {0, 1, . . . , 99} × {0, 1, . . . , 99} ⊂ Z
0+ × Z
0+.
The robot is a “rod” object, whose configuration is q = [x, y, θ], taking into account that x, y are the image
coordinates, therefore they are integer values in the grid and the orientation θ is also discretized into several
values.
All the required data can be obtained from data_ps1.npz. This numpy data file consists of the environment map [’environment’](np.ndarray([100,100])) an image with values 0 to indicate free
1
space and 1 to indicate an obstacle. The second component is the robot/agent, whose shape is included in
[’rod’](np.ndarray([11,11,4])). There are 4 dimensions to represent the different discretization orientations - the robot rotated by 0, 45, 90, 135 degrees positions.

A) (10 pts) Visualize from the given data the workspace and the different rod configurations for each discretized
orientation. Comment on the given discretized values for orientation.
"""

# Load the data from the npz file
data = np.load('data_ps1.npz')
environment_map = data['environment']
rod_shape = data['rod']

# Visualize the workspace
plt.figure(figsize=(6, 6))
plt.imshow(environment_map, cmap='Blues')
plt.title('Workspace Map')
plt.show()

# Visualize the different rod configurations for each orientation
orientations = ['0 degrees', '45 degrees', '90 degrees', '135 degrees']
fig, ax = plt.subplots(1, 4, figsize=(12, 3))
for i in range(4):
    ax[i].imshow(rod_shape[:, :, i], cmap='Blues')
    ax[i].set_title(orientations[i])

plt.suptitle('Rod Configurations for Discretized Orientations')
plt.show()

"""
**COMMENT:**

Regarding the discretized values for orientation, the provided rod shape contains four orientations: 0 degrees, 45 degrees, 90 degrees, and 135 degrees. These orientations are represented by images of the rod rotated by the respective angles in a clockwise direction. The rod position can be represented with a period of pi or 180 degrees."""

import numpy as np
import matplotlib.pyplot as plt
from utils import plot_enviroment

"""B) (10 pts) Visualize the environment together with the object. For this, you may want to use the function
plot_joint_environment from utils.py and select any valid configuration value for the rod.

"""

# Load the data from the npz file
data = np.load('data_ps1.npz')
environment_map = data['environment']
rod_shape = data['rod']

# Select a valid configuration value for the rod
configuration_value = (10,10,1)

# Plot the joint environment
plt.figure(figsize=(6, 6))
obj_and_environment = plot_enviroment(environment_map, rod_shape, configuration_value)
plt.title('Joint Environment')
plt.imshow(obj_and_environment,interpolation='none')
plt.show()

"""C) (10 pts) Create the C-space for the 2D environment map. For this, plot all the images corresponding to each
of the orientations by using collision checking.
hint: you might want to look at the library scipy.signal and use function signal.convolve2d(env_map,
kernel, boundary=’symm’, mode=’same’) to check for collisions.
hint: you may want to use normalize_image(img) from utils.py to normalize created space to {0, 1},
since after convolutions, values are not exactly 0 and 1 (this will be useful for task 2).

"""

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
from scipy.signal import convolve2d
from utils import normalize_image

# Load the data from the npz file
data = np.load('data_ps1.npz')
environment_map = data['environment']
rod_shape = data['rod']

#Normalize environment map
env_map = normalize_image(environment_map)

# Define the kernel as the rod shape (flipped)
kernel = np.flip(rod_shape)

# Create an array to store the C-space images for each orientation
c_space = np.zeros_like(environment_map, dtype=np.float64)

# Compute the C-space image for each orientation
orientation = 4
for i in range(orientation):
    # Rotate the kernel according to the current orientation
    rotated_kernel = np.rot90(rod_shape[:,:,i],i)

# Convolve the environment map with the rotated kernel
collision_map=signal.convolve2d(env_map, rotated_kernel, mode='same', boundary='fill',fillvalue=1)

# Set the collision pixels in the C-space image to 1
c_space[collision_map > 0] = 1

# Plot the C-space image for the current orientation
plt.figure(figsize=(6, 6))
plt.imshow(c_space, cmap='gray')
plt.title('Orientation: {} degrees'.format(orientation * 45))
plt.axis('off')
plt.show()
plt.close()

"""D) (10 pts) Comment on the obtained C-space with the previous method. What is the size of the C-space?

**COMMENT**

The obtained C-space using the previous method represents the collision-free areas in the environment map for each orientation of the rod. The C-space images indicate where the rod can move without colliding with obstacles in the environment.

The size of the C-space is the same as the size of the environment map which is 100 x 100 . The C-space is a two-dimensional grid with the same dimensions as the environment map, where each pixel represents a position in the map. Each pixel in the C-space image corresponds to a location in the environment map and indicates whether that location is collision-free (1) or collides with an obstacle (0).

In other words, the size of the C-space is equal to the width multiplied by the height of the environment map. If the environment map has dimensions of M x N, the C-space will also have dimensions of M x N.

**Task** **2:** **A star Algorithm (60 points)**  

For this task, you will implement a graph search algorithm. The actions allowed in this problem are moving up,
down, left, right, rotate right, rotate left. In total 6 actions, each of them has an assigned a cost of 1.

A) (40 pts) You need to implement the A star algorithm and plan in the generated discrete C-space from the
previous task. The starting configuration of the agent is (6,6,2) and the goal configuration is (55,55,0). On
this first iteration, use an heuristic function h(q, qG) = 0, which is equivalent to the Dijkstra algorithm.
Save the result of calculated plan in rod_solve.mp4 using plotting_result(environment,rod,plan)
from utils.py, where plan is list of rod states from start to goal.
hint: Track the number of visited states to avoid/debug potential issues with internal loops.
"""

import numpy as np
from queue import PriorityQueue
from utils import plotting_results

def heuristic(q, qG):
    return 0  # Dijkstra's algorithm (no heuristic)

def move_up(q):
    if q[1] < 59:
        return (q[0], q[1] + 1, q[2])
    return q

def move_down(q):
    if q[1] > 0:
        return (q[0], q[1] - 1, q[2])
    return q

def move_left(q):
    if q[0] > 0:
        return (q[0] - 1, q[1], q[2])
    return q

def move_right(q):
    if q[0] < 59:
        return (q[0] + 1, q[1], q[2])
    return q

def rotate_left(q):
    return (q[0], q[1], (q[2] - 1) % 4)

def rotate_right(q):
    return (q[0], q[1], (q[2] + 1) % 4)

def actions(q):
    return [move_up(q), move_down(q), move_left(q), move_right(q),
            rotate_left(q), rotate_right(q)]

def cost(q1, q2):
    return 1

def cost(q1, q2):
    return 1

def a_star(start, goal):
    visited = set()
    g_scores = {start: 0}
    f_scores = {start: heuristic(start, goal)}
    frontier = PriorityQueue()
    frontier.put((f_scores[start], start))

    parent = {}

    while not frontier.empty():
        _, current = frontier.get()

        if current == goal:
            return construct_path(parent, current)

        visited.add(current)

        action = None

        for action in actions(current):
          if action in visited:
               continue

          new_cost = g_scores[current] + cost(current, action)

          if action not in g_scores or new_cost < g_scores[action]:
            g_scores[action] = new_cost
            f_scores[action] = new_cost + heuristic(action, goal)
            parent[action] = current
            frontier.put((f_scores[action], action))

def construct_path(parent, current):
    path = [current]

    while current in parent:
        current = parent[current]
        path.append(current)

    return path[::-1]

# Define the start and goal configurations
start = (6, 6, 2)
goal = (55, 55, 0)

# Run A* algorithm to find the path
plan = a_star(start, goal)

if plan:
  print("Path found: ",plan)
  print("Final path cost: ",len(plan))
else:
  print("No path found")

# Plotting the result
plotting_results(environment_map, rod_shape, plan,'rod_solve.mp4')

"""B)  (10 pts) Change the heuristic function now to be h(q, qG) = L1 norm of the x, y components. Comment on
the changes, how many states have been visited compared to Dijkstra? What is the final cost?
Comment on the results.
"""

#A* Heuristics

def l1_norm (node,goal):
  m1,n1,_ = node
  m2,n2,_ = goal
  return abs(m1 - m2)+ abs(n1 - n2)

def move_up(q):
    if q[1] < 59:
        return (q[0], q[1] + 1, q[2])
    return q

def move_down(q):
    if q[1] > 0:
        return (q[0], q[1] - 1, q[2])
    return q

def move_left(q):
    if q[0] > 0:
        return (q[0] - 1, q[1], q[2])
    return q

def move_right(q):
    if q[0] < 59:
        return (q[0] + 1, q[1], q[2])
    return q

def rotate_left(q):
    return (q[0], q[1], (q[2] - 1) % 4)

def rotate_right(q):
    return (q[0], q[1], (q[2] + 1) % 4)

def actions(q):
    return [move_up(q), move_down(q), move_left(q), move_right(q),
            rotate_left(q), rotate_right(q)]

def cost(q1, q2):
    return 1

def cost(q1, q2):
    return 1

def a_star2(start, goal):
    visited = set()
    g_scores = {start: 0}
    f_scores = {start: l1_norm(start, goal)}
    frontier = PriorityQueue()
    frontier.put((f_scores[start], start))

    parent = {}

    while not frontier.empty():
        _, current = frontier.get()

        if current == goal:
            return construct_path(parent, current)

        visited.add(current)

        action = None

        for action in actions(current):
          if action in visited:
               continue

          new_cost = g_scores[current] + cost(current, action)

          if action not in g_scores or new_cost < g_scores[action]:
            g_scores[action] = new_cost
            f_scores[action] = new_cost + l1_norm(action, goal)
            parent[action] = current
            frontier.put((f_scores[action], action))

def construct_path(parent, current):
    path = [current]

    while current in parent:
        current = parent[current]
        path.append(current)

    return path[::-1]

# Define the start and goal configurations
start = (6, 6, 2)
goal = (55, 55, 0)

# Run A* algorithm to find the path
plan = a_star2(start, goal)

if plan:
  print("Path found: ",plan)
  print("Final path cost: ",len(plan))
else:
  print("No path found")

# Plotting the result
plotting_results(environment_map, rod_shape, plan,'rod_solve2.mp4')

"""**COMMENT**

Changing the heuristic function to be the L1 norm of the x and y components (h(q, qG) = |x - xG| + |y - yG|) will lead to a different search behavior compared to Dijkstra's algorithm.

The L1 norm, also known as the Manhattan distance, measures the shortest path between two points along vertical and horizontal lines. It does not consider diagonal movements. This means that the search will prioritize moving vertically and horizontally rather than diagonally.

By using the L1 norm as the heuristic function, the A algorithm will likely explore fewer states compared to Dijkstra's algorithm. This is because the L1 norm tends to underestimate the true cost of reaching the goal, which can guide the search towards the goal more directly.

The final cost of the optimized path found by A with the L1 norm heuristic will depend on the specific problem and environment. It may be lower or higher than the final cost obtained with the Dijkstra algorithm. However, in general, A with an admissible heuristic should find a solution that is at least as good as Dijkstra's algorithm in terms of the cost.

However, in our case, we got the same cost for Dijkstra's algorithm as we as with the A Star algorithm with manhattan distance cost of 101.

C) (10 pts) Propose an heuristic function h(q, qG) that includes orientation. Compare metrics with the previous
results. Comment on the results
"""

import math
import heapq

def heuristic3(q, qG, w):
    x, y, θ = q
    xG, yG, θG = qG
    dist = math.sqrt((x - xG)**2 + (y - yG)**2)
    orient_dist = w * abs(θ - θG)
    return dist + orient_dist

def a_star_search3(start, goal, w):
  visited = set()
  g_scores = {start: 0}
  f_scores = {start: heuristic3(start, goal,w)}
  frontier = PriorityQueue()
  frontier.put((f_scores[start], start))

  parent = {}

  while not frontier.empty():
        _, current = frontier.get()

        if current == goal:
            return construct_path(parent, current)

        visited.add(current)

        action = None

        for action in actions(current):
          if action in visited:
               continue

          new_cost = g_scores[current] + cost(current, action)

          if action not in g_scores or new_cost < g_scores[action]:
            g_scores[action] = new_cost
            f_scores[action] = new_cost + heuristic3(action, goal,w)
            parent[action] = current
            frontier.put((f_scores[action], action))

def construct_path(parent, current):
  path = [current]

  while current in parent:
      current = parent[current]
      path.append(current)

  return path[::-1]

# Define the start and goal configurations
start = (6, 6, 2)
goal = (55, 55, 0)
w = 1

# Run A* algorithm to find the path
plan = a_star_search3(start, goal,w)

if plan:
  print("Path found: ",plan)
  print("Final path cost: ",len(plan))
else:
  print("No path found")

# Plotting the result
plotting_results(environment_map, rod_shape, plan,'rod_solve3.mp4')

"""**COMMENT**
To include orientation in the heuristic function, we can calculate the Euclidean distance between the current position (x, y) and the goal position (xG, yG) and add a scaling factor based on the difference in orientations.

We can define the heuristic function as h(q, qG) = sqrt((x - xG)^2 + (y - yG)^2) + w  abs(θ - θG), where (x, y) represents the current position, (xG, yG) represents the goal position, θ represents the current orientation, θG represents the goal orientation, and w is a scaling factor to adjust the importance of orientation.

By incorporating orientation information, the heuristic function will guide the search towards positions and orientations that are closer to the goal, taking into account both the spatial and directional aspects of the problem.

Using the above heuristic function, we get the same cost as the Dijkstra's algorithm and A_star with L1 norm. But the path followed varies.
"""